"===============================================================================
" https://github.com/everbot/dotfiles
"
" Mini .vimrc setting for Vim and GVim
"
" The purpose of this file is to provide some basic functionalities to edit text
" with Vim without any plugin dependent. This is best suited for light-editing
" works.
"
" This file can also be used as a stand-alone .vimrc file
"===============================================================================

" disable compatibility to vi because it's annoying.
" compatibility with vi make `imap jk <ESC>` doesn't work
set nocompatible

" use system clipboard for normal yank/paste
" set clipboard=unnamedplus

" set font for gvim
if has('gui_running')
    " use Powerline font for vim-airline
    " set guifont=Dejavu\ Sans\ Mono\ for\ Powerline\ 9
    " set guifont=Dejavu\ Sans\ Mono\ 12
    " set guifont=Droid\ Sans\ Mono\ 16
    " set guifont=Inconsolata-g\ for\ Powerline\ 9
    " set guifont=PragmataPro\ 10
    " set guifont=Ubuntu\ Mono\ derivative\ Powerline\ 12

    if has("gui_gtk2")
        set guifont=Dejavu\ Sans\ Mono\ for\ Powerline\ 9
    elseif has("gui_macvim")
        set guifont=Menlo\ Regular:h14
    elseif has("gui_win32")
        " set font for GVim in Windows
        set guifont=Consolas:h10:cANSI
    endif
endif

" Rebind <Leader> key. when you pressed the Leader key, the cursor
" will wait for 1s for user to press another key
let mapleader = ","

" display relative line number with the current line
" to turn off: set norelativenumber
" Comment it out because it seems slow
" set relativenumber

" ==============================================================================
" Save stroke when saving file with Ctrl+s
" http://vim.wikia.com/wiki/Map_Ctrl-S_to_save_current_or_new_files
" If the current buffer has never been saved, it will have no name,
" call the file browser to save it, otherwise just save it.
command! -nargs=0 -bar Update if &modified
                           \|    if empty(bufname('%'))
                           \|        browse confirm write
                           \|    else
                           \|        confirm write
                           \|    endif
                           \|endif
nnoremap <silent> <C-S> :<C-u>Update<CR>
" 'gv' preserves the previous selection
vnoremap <C-s> <esc>:Update<CR>gv
inoremap <c-s> <c-o>:Update<CR>
" ==============================================================================

" Move a line of text using ALT+[jk] or Comamnd+[jk] on mac
nmap <M-j> mz:m+<cr>`z
nmap <M-k> mz:m-2<cr>`z
vmap <M-j> :m'>+<cr>`<my`>mzgv`yo`z
vmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`z

" Set tab label to show tab number, filename, if modified ('+' is shown if the
" current window in the tab has been modified)
set guitablabel=%N)\ %t\ %M

imap jk <ESC>

" write file with super user permission
cmap w!! w !sudo tee %

" set line number
set nu

set tabstop=4 expandtab
set softtabstop=4
set shiftwidth=4
set shiftround

"display status bar at the bottom which shows file name and cursor position
set laststatus=2

"display title bar of the current vim window
set title

syntax on

" set autoindent
set ai

" make search case insensitive
set hlsearch
set incsearch
set ignorecase
set smartcase

" disable stupid backup and swap files - they trigger too many events
" for file system watchers
set nobackup
set nowritebackup
set noswapfile

" Use Alt+number to go to a specific tab number
nnoremap <A-1> 1gt
nnoremap <A-2> 2gt
nnoremap <A-3> 3gt
nnoremap <A-4> 4gt
nnoremap <A-5> 5gt
nnoremap <A-6> 6gt
nnoremap <A-7> 7gt
nnoremap <A-8> 8gt
nnoremap <A-9> 9gt
nnoremap <A-0> 10gt

" use Shift+q to format a paragraph to do wrapping at 80 chars
" commented out on 2015-04-02 to make it automatically join short lines
" together: " set formatoptions+=w
set tw=80
set colorcolumn=+1 "set color for column at 81
"hi ColorColumn guibg=#3E3F36 ctermbg=236
hi ColorColumn ctermbg=236
nnoremap Q gqip

" auto reload the file if it's changed
set autoread

" use Ctrl + l to redraw the screen and remove any search highlighs
nnoremap <silent> <C-l> :nohl<CR><C-l>


" toggling cursorline highlight when switching on/off insert mode
autocmd InsertEnter,InsertLeave * set cul!
" or:
" autocmd InsertEnter * set cul
" autocmd InsertLeave * set nocul


" highlight tab and trailing space
set listchars=tab:>-,trail:-
set list
" use F11 to toggle between displaying white space or not
noremap <F11> :set list!<CR>


"match the tab, so it will make the cursorline doesn't change the color of
"specialkey foreground color when the cursor goes to that line (this happens
"when highligh tab and trailing space is enabled
match NonText '^\s\+' "

" reload the updated .vimrc profile
nmap <Leader>rr :source $MYVIMRC

" quickly open to edit .vimrc file
nmap <Leader>v :tabe $MYVIMRC


" quickly comment out block of code
map ,- :s/^/--/<CR>
map ,# :s/^/#/<CR>
map ,% :s/^/%/<CR>
map ,/ :s/^/\/\//<CR>

"cancel the comment
" comment out 2015-04-02 because of parsing error when vim is starting
" map ,c :s/^\/\/\\|^--\\|^> \\|^[#"%!;]//<CR>


" use single z to move the current line to the center view.
" by doing this mapping, the zt and zb doesn't work. But I don't use zt and zb
" anyway, so this is not a big deal!
" nnoremap z zz

" use Ctrl+d to move the cursor to bottom, then bring that bottom line to middle
" of screen
noremap <silent> <C-d> <S-l>zz

" use Ctrl+u to move the cursor to top of the page, then bring that top line
" to middle of screen
noremap <silent> <C-u> <S-h>zz


" enable suggestion of available of commands in commands mode, so that we can
" use arrow keys (or Ctrl+n and Ctrl+p) to choose a desire command form the list
" Active the wildmenu by entering command mode (:) then type in the first few
" character and then press Tab
set wildmenu

" Use Ctrl+Backspace to change the current directory globaly to the current file
" To change localy use :lcd %:p:h
" In these commands, % gives the name of the current file, %:p gives its full
" path, and %:p:h gives its directory (the "head" of the full path)
" nnoremap <c-d> :cd %:p:h<CR>
nnoremap <c-BS> :cd %:p:h<CR>

"easier moving of code blocks
vnoremap < <gv " better indentation
vnoremap > >gv " better indentation

" Uncomment the following to have Vim jump to the last position when
" reopening a file
if has("autocmd")
   au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
endif


" map F5 to quickly ROT13 the whole buffer, juz for fun
" map <F5> ggg?G``

" auto unfold everything when open a file
autocmd BufWinEnter * silent! :%foldopen!

" The below commands work with system clipboard too
" copy: Ctrl+c
" cut: Ctrl+x
" paste: Ctrl+v
" Paste only works in Visual and insert mode, so you don't have to worry about
" the conflict with Ctrl-V and blockwise Visual Mode. This isn't a problem,
" because Copy and Cut put you into insert mode, so you can immediately paste
" afterwards. If you try it out you'll find that it feels completely natural.
" http://superuser.com/questions/10588/how-to-make-cut-copy-paste-in-gvim-on-
" ubuntu-work-with-ctrlx-ctrlc-ctrlv
vmap <C-c> "+yi
vmap <C-x> "+c
vmap <C-v> c<ESC>"+p
imap <C-v> <C-r><C-o>+

" allowing auto remove trailing white space characters
fun! <SID>StripTrailingWhitespaces()
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    call cursor(l, c)
endfun

" remove trailing whitespace upon save
"autocmd FileType c,cpp,java,php,ruby,python autocmd BufWritePre <buffer> :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre * :call <SID>StripTrailingWhitespaces()

" resize current buffer by +/- 5
nnoremap <C-left> :vertical resize -5<cr>
nnoremap <C-down> :resize +5<cr>
nnoremap <C-up> :resize -5<cr>
nnoremap <C-right> :vertical resize +5<cr>

" map shortcut key for spelling
noremap <F6> :setlocal spell! spelllang=en_us<CR>

" set folding method for C code
" :setlocal foldmethod=syntax
autocmd FileType c,java,cpp,python setlocal foldmethod=syntax

nmap <silent> <RIGHT> :cnext<CR>
nmap <silent> <RIGHT><RIGHT> :cnfile<CR><C-G>
nmap <silent> <LEFT> :cprev<CR>
nmap <silent> <LEFT><LEFT> :cpfile<CR><C-G>


" bind Ctrl + <movement> keys to move around the windows
" commented out because some Ctrl+<movement> keybinding are already in used
" map <c-j> <c-w>j
" map <c-k> <c-w>k
" map <c-l> <c-w>l
" map <c-h> <c-w>h

" map sort function to a key
vnoremap <Leader>z :sort<CR>


" ==============================================================================
" run the current buffer python code
" nnoremap <buffer> <F9> :exec '!python' shellescape(@%, 1)<cr>
" nnoremap <F9> :exec '!python' shellescape(@%, 1)<cr>

" Use F8 to compile and run C program
" map <F8> :exec ':!gcc -std=c99 % -o  a.cout && ./a.cout'<cr>

" Use F7 to compile and run Cpp program
" map <F7> :exec ':!g++ % -o a.cout && ./a.cout'<cr>


function! CompileCode()
    " first change dir to the place where the current file is located
    " let curDir = system('pwd') " the result has @ at the end
    let curDir = getcwd() " get current working directory
    let targetDir = expand('%:p:h') " get the dir contains the current buffer
    echom "curDir = " . curDir
    if (curDir != targetDir)
        echom "Changing dir to " . targetDir
        exec 'cd %:p:h'
    else
        echom "Already at the " . curDir
    endif

    echom '-------'

    if (&filetype == 'cpp')
        exec ':!g++ % -o a.cout && ./a.cout'
    elseif (&filetype == 'c')
        exec ':!gcc -std=c99 % -o  a.cout && ./a.cout'
    elseif (&filetype == 'python')
        exec '!python' shellescape(@%, 1)
    elseif (&filetype == 'java')
        exec ':!javac % && java -cp %:p:h %:t:r'
    elseif (&ft == 'html')
        exec '!firefox % &'
    elseif (&ft == 'lisp')
        LisperEvalBuffer
    elseif (&ft == 'clojure')
        exec '%Eval'
    endif
endfunction

" Use F9 to compile and run the code in the current buffer
nmap <F9> :call CompileCode()<CR>
" ==============================================================================

" Space to toggle folds.
nnoremap <Space> za
vnoremap <Space> za

" ==============================================================================
" http://vim.wikia.com/wiki/Move_current_window_between_tabs
function! MoveToPrevTab()
  "there is only one window
  if tabpagenr('$') == 1 && winnr('$') == 1
    return
  endif
  "preparing new window
  let l:tab_nr = tabpagenr('$')
  let l:cur_buf = bufnr('%')
  if tabpagenr() != 1
    close!
    if l:tab_nr == tabpagenr('$')
      tabprev
    endif
    sp
  else
    close!
    exe "0tabnew"
  endif
  "opening current buffer in new window
  exe "b".l:cur_buf
endfunc

function! MoveToNextTab()
  "there is only one window
  if tabpagenr('$') == 1 && winnr('$') == 1
    return
  endif
  "preparing new window
  let l:tab_nr = tabpagenr('$')
  let l:cur_buf = bufnr('%')
  if tabpagenr() < tab_nr
    close!
    if l:tab_nr == tabpagenr('$')
      tabnext
    endif
    sp
  else
    close!
    tabnew
  endif
  "opening current buffer in new window
  exe "b".l:cur_buf
endfunc
" ==============================================================================


" Below is from Windows' GVIM example setting
" Don't use the below function as it interfere with :Gdiff command
" set diffexpr=MyDiff()
" function MyDiff()
"   let opt = '-a --binary '
"   if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
"   if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
"   let arg1 = v:fname_in
"   if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
"   let arg2 = v:fname_new
"   if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
"   let arg3 = v:fname_out
"   if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
"   let eq = ''
"   if $VIMRUNTIME =~ ' '
"     if &sh =~ '\<cmd'
"       let cmd = '""' . $VIMRUNTIME . '\diff"'
"       let eq = '"'
"     else
"       let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
"     endif
"   else
"     let cmd = $VIMRUNTIME . '\diff'
"   endif
"   silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
" endfunction

